# Building signals from AR coefficients and pitch trajectories.
"""

    TODO:   - replace oscillator with BLIT (?) then filter.

"""

import os
import numpy as np
from scipy.signal import lfilter, medfilt
from scipy.io import wavfile
from vibratospace.src.python.averaging import get_average_ar_coefficients
from vibratospace.src.python.oscillators import Blit, AdditiveOsc
from vibratospace.src.python.util import (
    midi_to_hz,
    to_sample_rate,
    normalize,
    add_fade,
    fix_deviation,
    hz_to_midi,
    repitch,
    load_data,
    remove_dc,
    widen
)
from vibratospace.src.python.defaults import (
    DATA_PATH,
    PROCESSED_PATH,
    SAMPLE_RATE,
    PITCH_RATE
)


if __name__ == '__main__':
    VERBOSE = True

    # Median filter kernel is for separating jitter.
    median_filter_size = 3

    # Fix re-synthesis vibrato width as std in semitones.
    pitch_deviation = 0.5

    # Alternately, expand the pitch trajectory by a multiplicative factor.
    pitch_widen = 1.5

    # Cosine ramp in/out for audio (in seconds).
    audio_fade = 0.25

    # Cosine ramp in/out for vibrato depth (in seconds).
    pitch_fade = 0.125

    # Note to recenter all stimuli (in midi: 48 == C3).
    repitch_note = 60

    # Load pitch and lpc data from .pickle file (generated by analysis.py).
    pickle_path = os.path.join(DATA_PATH, 'data.pickle')
    data = load_data(pickle_path)

    # Calculate average spectrum and generate ar coefficients.
    batch_coefficients = [d['lpc'] for d in data]
    average_coefficients = get_average_ar_coefficients(batch_coefficients)

    # Add negative control.
    blank_frequency = np.ones(len(data[0]['frequency']))

    data.append(
        {
            'filename': 'no_vibrato.wav',
            'frequency': blank_frequency
        }
    )

    # Sound generators.
    blit = Blit()
    additive = AdditiveOsc(num_harmonics=25)

    for datum in data:
        pitch = datum['frequency']
        pitch = hz_to_midi(pitch)
        pitch = repitch(pitch, repitch_note)

        # Remove and store jitter during pitch manipulation.
        jitter = pitch - medfilt(pitch, median_filter_size)
        pitch -= jitter

        # pitch = add_fade(pitch, pitch_fade, rate=PITCH_RATE)
        # pitch = fix_deviation(pitch, pitch_deviation)
        pitch = widen(pitch, pitch_widen)

        # Reintroduce jitter.
        pitch += jitter

        pitch = midi_to_hz(pitch)
        pitch = to_sample_rate(pitch)

        audio = blit(pitch)
        audio = lfilter([1], average_coefficients, audio)
        audio = remove_dc(audio)

        audio = normalize(audio)
        audio = add_fade(audio, audio_fade, rate=SAMPLE_RATE)

        filename = "proc_" + datum['filename']
        write_path = os.path.join(PROCESSED_PATH, filename)

        if VERBOSE:
            print("Writing {}...".format(filename))
        wavfile.write(write_path, SAMPLE_RATE, audio)
